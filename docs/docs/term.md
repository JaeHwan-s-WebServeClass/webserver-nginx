***

## 동기와 비동기
동기와 비동기는 네트워크 통신에서 발생하는 일련의 작업들을 처리하는 방식이자 데이터의 상태와 관련된다. 

1. `동기(synchronous)`
    - 요청을 보내고 응답이 올 때까지 기다리는 방식입니다. 
    - 즉, 요청과 응답이 순서대로 처리됩니다. 
    - 요청과 결과가 동시에 일어난다: 요청을 하면 (시간이 얼마나 걸리든) 요청한 자리에서 결과가 주어진다.

2. `비동기(asynchronous)`
    - 요청을 보낸 후에도 다른 작업을 처리할 수 있으며, 응답이 오면 알림을 받아 처리합니다. 
    - 따라서 비동기 방식은 요청과 응답이 동시에 처리되지 않을 수 있습니다.
    - 요청과 결과가 동시에 일어나지 않을 수 있다.

***

## blocking과 non-blocking
blocking과 non-blocking은 네트워크 입출력(I/O) 작업을 처리하는 방식을 나타냅니다. 

1. `blocking`
    - I/O 작업이 완료될 때까지 호출한 함수가 반환되지 않는 방식입니다. 
    - 즉, I/O 작업이 완료될 때까지 해당 스레드가 대기 상태에 있어야 합니다. 
    - 함수호출을 한 영역에서 프로그램이 (반환될 때까지) 대기하는 경우
    - 입출력 작업을 수행하는 함수가 호출되면 그 함수가 반환될 때까지 대기하므로, 호출한 함수가 `동기 방식`일 경우에 해당합니다.

2. `non-blocking`
    - I/O 작업이 완료되지 않더라도 호출한 함수가 즉시 반환됩니다. 
    - 이후에 결과를 확인하고자 할 때는 추가적인 작업이 필요합니다.
    - 함수호출을 한 영역에서 프로그램이 (반환될 때까지) 대기하지 않는 경우
    - 입출력 작업을 수행하면서 다른 작업도 수행할 수 있으므로 호출한 함수가 `비동기 방식`일 경우에 해당합니다.

***

- blocking socket
    - 일반적으로 소켓은 blocking socket으로 만들어진다. 즉, 읽기와 쓰기의 과정이 완전히 끝날 때까지 머물러있는다.
    - blocking socket을 사용하면 해당 영역에 머무르기 때문에 다른 IO 작업을 할 수 없다는 문제가 발생한다.

- non-blocking socket
    - (작성중)  

***

## I/O model

입출력 모델은 blocking/non-blocking과 동기/비동기의 조합에 따라 4가지가 존재한다.

1. blocking + 동기
    - read/write

2. blocking + 비동기
    - I/O 다중화

3. non-blocking + 동기
    - read/write (O_NONBLOCK)

4. non-blocking + 비동기 
    - AIO 리얼 타임 시그널

***

## LT(level triggered)와 ET(edge triggered)

LT와 ET는 네트워크 소켓에서 이벤트 처리 방식을 나타냅니다. 

1. `LT(level triggered)`
    - 이벤트가 발생한 후에는 이벤트가 해결될 때까지 이벤트를 계속해서 보고하는 방식입니다. 

2. `ET(edge triggered)`
    - 이벤트가 발생한 시점에서만 이벤트를 보고하며, 이벤트가 해결될 때까지는 다시 보고하지 않습니다.

***
